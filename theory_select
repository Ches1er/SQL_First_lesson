Команда SELECT используется для того, чтобы достать из таблицы какие-либо интересующие нас данные.
Данная команда говорит, что мы хотим что-то получить, например SELECT 2+2; выведет нам результат 4.
Синтаксис: SELECT что FROM откуда.
Если мы хотим выбрать несколько полей, то их можно перечислить через запятую, если необходимо вывести
информацию о всех полях, то пишем SELECT * FROM.

Выборка информации с условием:
SELECT что FROM откуда WHERE условие;
Например SELECT `user`,`password_expired` FROM `user` WHERE `user`='root'
Обратите внимание, что значение ячейки обязательно указывается в простых кавычках.
Также в условии можно использовать логические операции AND, OR, XOR, NOT.

Если мы хотим выбрать несколько пользователей, можно использовать след конструкцию:
SELECT `user`,`password_expired` FROM `user` WHERE `user` IN ('root','pma').
Особенностью данной конструкции является то, что в скобочках может быть указан какой либо подзапрос;
а не только явные данные, как в примере выше.

Для того, чтобы проверить значение на пустоту, следует использовать следующий синтаксис:
SELECT `user`,`password_expired` FROM `user` WHERE `user`
IN (SELECT `user` FROM `user` WHERE NOT ISNULL(`user`)).
Можно использовать следующие операторы сравнение: =,<,>,>=,<=,<>(не равно).

Оператор частичной выборки:
SELECT `user`,`password_expired` FROM `user` WHERE `user` LIKE ... .
Многоточие означает определенный шаблон, в котором "%" - некое множество символов, "_" - один символ.
Пример:  SELECT `user`,`password_expired` FROM `user` WHERE `user` LIKE 'r%'; - в данном случае
выберутся все пользователи, чье имя начинается на "r", неважно сколько символов в имени. Или
SELECT `user`,`password_expired` FROM `user` WHERE `user` LIKE '_оо_';
Можно также применять регулярные выражения.

Полный используемый синтаксис

SELECT <expressions>
FROM <table_reference> - описание таблиц
WHERE <condition> - условие выборки
GROUP BY <group_expression> - перечень колонок, по которым необходимо сгруппировать запрос
для группировки могут быть использованы свои условия, которые мы не можем использовать при WHERE,
они отрабатывают уже позже. Если мы уже после выборки по условию, хотим отфильтровать результат,
есть такой оператор HAVING <group_condition> - условия группировки, которые накладываются уже на
результат самой выборки. Обратите внимание, что HAVING без GROUP BY, существовать не может.
ORDER BY <expressions> [ASC|DESC] в каком порядке отсортируются результаты выборки.
Для того, чтобы ограничиться н-колвом результатов, есть конструкция:
LIMIT [<M>,<N>[OFFSET<M>]], где М может отсутствовать, тогда N - будет означать кол-во штук, либо,
если используем М, то OFFSET будет означать "пропустить М штук и выбрать N штук"

Агрегатные функции, из множества получаем что-либо одно.
SELECT SUM(`goods`)FROM `goods` или MIN или MAX, AVG - среднее;

SELECT MAX(`price`),`name` FROM `goods` GROUP BY `name` - выбор товаров с макс ценой, сгрупиированных
по имени.

Если мы хотим задать условие, например выбрать максимальную цену, но выше 200, то в WHERE использовать
агрегатную функцию нельзя, для этого используется HAVING
SELECT MAX(`price`),`name` FROM `goods` GROUP BY `name` HAVING MIN(`price`)>200;

В процессе выборки полям можно давать псевдоним

SELECT MAX(`price`) AS max_price,`name` FROM `goods` GROUP BY `name`;

Существует агрегатная функция конкатенации, например:
SELECT GROUP_CONCAT(`name`),price FROM `goods` GROUP BY `price`;
в данном случае мы получим в некоторых полях name значения типа tv,notebook. Т.е. значения имен
склеятся друг-с-другом.

Лимиты.

SELECT * FROM `goods` LIMIT 3; - выберет первые 3 товара, изначально сортировка идет по первичному ключу
SELECT * FROM `goods` LIMIT 3 OFFSET 2; - выберет первые 3 товара, пропустив 2.

Сортировка

SELECT * FROM `goods` ORDER BY `price` DESC LIMIT 1; - самый дорогой товар;

SELECT DICTINCT `name` FROM `goods`; - убирает полные дубликаты в выборке.

В Селекте в результатах выдачи можно склеивать строки, например:
SELECT CONCAT(`name`,`price`) FROM `goods`; результат будет в одной колонке и будет выглядеть как:
tv1000.
Можно сделать вот так:  SELECT CONCAT(`name`,`->`,`price`) FROM `goods`; результат будет в
одной колонке и будет выглядеть как: tv->1000.

Объединение результатов запроса.
Товар с минимальной ценой
SELECT `name` FROM `goods` ORDER BY `price` ASC LIMIT 1;
Товар с максимальной ценой
SELECT `name` FROM `goods` ORDER BY `price` DESC LIMIT 1;
Если необходимо выбрать и с минимальной и с максимальной, то используется Юнион:
(SELECT `name` FROM `goods` ORDER BY `price` ASC LIMIT 1) UNION
(SELECT `name` FROM `goods` ORDER BY `price` DESC LIMIT 1);
При использовании UNION результаты выборки должны совпадать по типу и кол-ву ячеек.
В Microsoft SQL Server есть INTERSECT пересечение, т.е. только те записи которые есть и там и так
и EXCEPT - все кроме пересекающихся.

Вставка в таблицу основываясь на данных выборки другой таблицы
INSERT INTO `goods`(`name`,`price`) SELECT 'tv',`price` FROM `goods` WHERE `name`='notebook'
ORDER BY `price` DESC LIMIT 1;

Кол-во чего либо.
SELECT COUNT(*) FROM `goods`; - выведет кол-во всех позиций товаров.

